from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import socket
import hashlib
import secrets
import ecdsa
import time 
gateway_address = ('localhost', 12345)
user_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
user_socket.connect(gateway_address)

curve = ecdsa.NIST256p

IDi = "abc"
IDg = "def"
IDj = "ghi"
Si = "secret of user"

Ki = "xyz" # KEY generated by FUZZY 


def generate_symmetric_key():
    return secrets.token_bytes(16) 

def generate_ecc_keys_bytes():
    # Generate private key
    private_key = ecdsa.SigningKey.generate(curve=curve)

    # Generate public key from private key
    public_key = private_key.verifying_key

    # Convert keys to bytes
    private_key_bytes = private_key.to_string()
    public_key_bytes = public_key.to_string()

    return private_key_bytes, public_key_bytes


user_private_key, KUi = generate_ecc_keys_bytes()
gateway_private_key, KG = generate_ecc_keys_bytes()   #  KG = GATEWAY PUBLIC KEY
device_private_key, KDj = generate_ecc_keys_bytes()

KUiG = secrets.token_bytes(16)
# NOTe -> PUBLIC KEY GENERATED IS NOT IN THE FORM OF BYTE (ITS IN STRING)

Ni = secrets.token_bytes(16)

TDi = hashlib.md5(IDi.encode() + KUi + Ni).hexdigest()
TDg = hashlib.md5(IDg.encode() + KG + Ni).hexdigest()
TDj = hashlib.md5(IDj.encode() + KDj + Ni).hexdigest()
Ci = hashlib.md5(TDi.encode() + TDg.encode() + TDj.encode() + Ni).hexdigest()

print("TDi : ", TDi)
print("TDg : ", TDg)
print("TDj : ", TDj)
print("Ni : ", Ni.hex())
print("Ci : ", Ci)
print("Ki : ", Ki)
print("KUiG : ", KUiG.hex())



user_socket.send(TDi.encode())
user_socket.send(TDg.encode())
user_socket.send(TDj.encode())
user_socket.send(Ni)
user_socket.send(Ci.encode())
user_socket.send(Ki.encode())
user_socket.send(KUiG)


# message_from_gateway_1 = user_socket.recv(1024).decode()

# M, PU, NGi, Ci, R = message_from_gateway_1.strip('<>').split(',')


M = user_socket.recv(32)
PU = user_socket.recv(3)
NGi = user_socket.recv(32)
Ci = user_socket.recv(32)
R = user_socket.recv(32)
print("\n---------USER-----------")
print("M : ", M.hex())
print("PU : ", PU.hex())
print("NGi : ", NGi.hex())
print("Ci : ", Ci.hex())



hash_user = hashlib.md5(M + PU + NGi + IDi.encode()).hexdigest()
SGi = bytes(a ^ b for a, b in zip(Ci, hash_user.encode()))#, SGi.to_bytes((SGi.bit_length() + 7) // 8, byteorder='big')))
Ci_XOR_SGi = bytes(a ^ b for a, b in zip(Ci, SGi))





print("SGi : ", SGi)

# print("Ci_XOR_SGi : ", Ci_XOR_SGi)
# print("hash_user: ", hash_user)
# if(Ci_XOR_SGi == hash_user):
#     print("\nINTEGRITY OF THE MESSAGE VERIFIED")
# else:
#     print("\nIntegrity verification FAILED")

# SECRET GENERATION
si = (int.from_bytes(Si.encode(), 'big') + int.from_bytes(R, 'big')) % curve.order
Secret_generated = ((2 * si) - int.from_bytes(SGi, 'big')) % curve.order
print("Secret Generated: ", Secret_generated)
print("Si : ", int.from_bytes(Si.encode(), 'big'))

if(int.from_bytes(Si.encode(), 'big') == Secret_generated):
    print("SECRET SUCCESSFULLY VERIFIED")
else:
    print("WRONG SECRET")



Vi = hashlib.md5(Si.encode() + IDi.encode()).hexdigest()
NG = bytes(a ^ b ^ c for a, b, c in zip(PU, SGi, IDi.encode()))

Vj = bytes(a ^ b ^ c for a, b, c in zip(M, Vi.encode(), NG))
KS = hashlib.md5(Vi.encode() + NG + Vj).digest()

specific_bytes = Vi[0:3]

# print("Vi encode : ", Vi.encode())


# print("Vi = ", Vi)
# print("NG = ", NG)
# print("Vj = ", Vj)
# print("specific_byte - Vi",specific_bytes)

KS_new = hashlib.md5(specific_bytes.encode() + NG + Vj).digest()

# print("\n\nspecific_bytes.encode - Vi: ", specific_bytes.encode())
# print("NG : ", NG)
# print("Vj.encode : ", Vj)

KS_new_str = str(KS_new.hex())
with open("Session_Key.txt", "w") as f:
    f.write(KS_new_str)

print("Session key (KS) on the USER side:", KS_new.hex())

user_socket.close()